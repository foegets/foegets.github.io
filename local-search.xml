<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java from c++</title>
    <link href="/2023/07/03/javafromc++/"/>
    <url>/2023/07/03/javafromc++/</url>
    asdfasdfa
    <content type="html"><![CDATA[<h2 id="Java与c-不同之处"><a href="#Java与c-不同之处" class="headerlink" title="Java与c++不同之处"></a>Java与c++不同之处</h2><h4 id="1-break带标签语法，即使用break和continue语句实现c-中goto的功能，跳出多重嵌套"><a href="#1-break带标签语法，即使用break和continue语句实现c-中goto的功能，跳出多重嵌套" class="headerlink" title="1.break带标签语法，即使用break和continue语句实现c++中goto的功能，跳出多重嵌套"></a>1.break带标签语法，即使用break和continue语句实现c++中goto的功能，跳出多重嵌套</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GotoDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        label: <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++) &#123;<br>                System.out.println(j);<br>                <span class="hljs-keyword">if</span> (j % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span> label;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-java中非布尔变量不能隐式转换为布尔变量"><a href="#2-java中非布尔变量不能隐式转换为布尔变量" class="headerlink" title="2.java中非布尔变量不能隐式转换为布尔变量"></a>2.java中非布尔变量不能隐式转换为布尔变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br><span class="hljs-type">boolean</span> isd=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(a)&#123;&#125;<span class="hljs-comment">//这是不允许的       </span><br><span class="hljs-keyword">if</span>(isd)&#123;&#125;<span class="hljs-comment">//这是正确的</span><br></code></pre></td></tr></table></figure><h4 id="3-new的数组与c-有较大不同"><a href="#3-new的数组与c-有较大不同" class="headerlink" title="3.new的数组与c++有较大不同"></a>3.new的数组与c++有较大不同</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br><span class="hljs-comment">//c++ int* arr=new int[5]; []等同于*</span><br>System.out.println(Arrays.toString(arr));<br><span class="hljs-comment">//结果[0, 0, 0, 0, 0]，即new出的数组已经进行了值初始化</span><br><span class="hljs-comment">//另外我们调用了Array.toString()方法</span><br>System.out.println(arr.length);<br><span class="hljs-comment">//结果：5，可想而知我们new出来的其实不是一个c++中的数组</span><br></code></pre></td></tr></table></figure><p>java中的数组是一种数组类，里面封装了数组长度length,与<code>Arrays</code>是不同的。另外，java中数组类的对象可以由另一中方式定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span>[] brr=arr;<br><span class="hljs-comment">//brr和arr是指向同一个数组对象的指针</span><br>brr[<span class="hljs-number">0</span>]=<span class="hljs-number">10</span>;<br>System.out.println(arr[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">//10</span><br><span class="hljs-type">int</span>[][] crr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>][<span class="hljs-number">5</span>];<br>crr[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br>System.out.print(crr[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<span class="hljs-comment">//print不同于在不加/n</span><br><span class="hljs-comment">//结果：1，二维数组的创建</span><br></code></pre></td></tr></table></figure><h4 id="4-switch-case扩展"><a href="#4-switch-case扩展" class="headerlink" title="4.switch-case扩展"></a>4.<code>switch-case</code>扩展</h4><p>字符串可以作为<code>switch-case</code>的判断量，要在java1.7以上才能用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">    String s1=<span class="hljs-string">&quot;01234苏&quot;</span>;<br>    <span class="hljs-keyword">switch</span>(s1)<br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;012&quot;</span>:<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;01234苏&quot;</span>:<br>            System.out.println(<span class="hljs-string">&quot;s1只是管理者&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">//s1只是管理者,相当于一个指针指向String类对象</span><br>```    <br><br>#### <span class="hljs-number">5.</span>java中的包裹类——对象包装器<br>java中的每种内置类型都有对应的包裹类，`<span class="hljs-type">int</span>`-`Integer`,`<span class="hljs-type">double</span>`-`Double`,`Short`-`<span class="hljs-type">short</span>`,Long-<span class="hljs-type">long</span>...内置类型不能使用于容器(如HashMap...),需要用对应包裹类作为容器所接收的类型<br>```java<br>     HashSet&lt;<span class="hljs-type">int</span>&gt; hs=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;<span class="hljs-type">int</span>&gt;();        <span class="hljs-comment">//x</span><br>     HashSet&lt;integer&gt; he=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;integer&gt;();<span class="hljs-comment">//√</span><br>     <span class="hljs-comment">//用包裹类不会影响使用</span><br></code></pre></td></tr></table></figure><h4 id="6-java对强制类型转换的处理"><a href="#6-java对强制类型转换的处理" class="headerlink" title="6.java对强制类型转换的处理"></a>6.java对强制类型转换的处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//有这样两个类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span>&#123;...&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Employee</span>&#123;...&#125;<br>Employee em=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Manager</span>();<br>Employee ma=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>();<br>Manager er=(Manager)em;<span class="hljs-comment">//合理，编译器知道em的实际对象</span><br>er=(Manager)ma;        <span class="hljs-comment">//抛出ClassCastException异常</span><br></code></pre></td></tr></table></figure><p>实际工作中有可能会有强制类型转换的需要，但是有什么办法判断这个类型转换是否成功呢，我们知道在c++中可以通过返回的指针是否为NULL判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//c++</span><br>er=<span class="hljs-keyword">dynamic_cast</span>&lt;Manager&gt;ma;   <br><span class="hljs-keyword">if</span>(er!=<span class="hljs-literal">NULL</span>)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;类型转换成功\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在java中有<code>instanceof</code>判断，<code>em</code>能够转换成<code>Manager</code>就返回<code>true</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(em <span class="hljs-keyword">instanceof</span> Manager)&#123;<br>   er=(Manager)em;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-default关键字"><a href="#7-default关键字" class="headerlink" title="7.default关键字"></a>7.default关键字</h4><h4 id="8-static-静态代码块与匿名代码块"><a href="#8-static-静态代码块与匿名代码块" class="headerlink" title="8.static-静态代码块与匿名代码块"></a>8.static-静态代码块与匿名代码块</h4><p>java中static除了用于与c++中相同的静态变量和静态方法之外，还有静态代码块这一用处，在匿名代码块前加上关键字static即可成为匿名代码块，在类加载时会调用静态代码块，因此只会调用一次，而匿名代码块则在每次new一个对象时都会调用一次。另外，接口是不能有静态语句块的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">anomymity</span> &#123;<br>&#123;<br>System.out.println(<span class="hljs-string">&quot;anomymity code&quot;</span>);<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> value=<span class="hljs-number">19</span>;<br><span class="hljs-keyword">static</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;static codes&quot;</span>+<span class="hljs-string">&quot;static int &quot;</span>+value);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">anomymity</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">anomymity</span>();<br>&#125;<br>   <span class="hljs-comment">//运行结果</span><br>   <span class="hljs-comment">//static codesstatic int 19</span><br>   <span class="hljs-comment">//anomymity code</span><br>   <span class="hljs-comment">//anomymity code</span><br>&#125;<br></code></pre></td></tr></table></figure><p>另外从上面示例代码中，Static code block能够调用static variable，因此static variable在static code block之前就定义了，但是就只是这样就简单判断了吗？不，我们要看一下java的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">anomymity</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;anomymity code&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] var0)</span> &#123;<br>       <br>    &#125;<br>     <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;static codes&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//静态部分的字节码</span><br><span class="hljs-keyword">static</span> &#123;&#125;;<br>    Code:<br>       <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>                  <span class="hljs-comment">//将(int)10入栈</span><br>       <span class="hljs-number">2</span>: putstatic     #<span class="hljs-number">5</span>                  <span class="hljs-comment">//出栈给静态变量value赋值10</span><br>       <span class="hljs-number">5</span>: getstatic     #<span class="hljs-number">2</span>                  <span class="hljs-comment">//取静态对象System.out</span><br>       <span class="hljs-number">8</span>: ldc           #<span class="hljs-number">6</span>                  <span class="hljs-comment">//将static code字符串常量入栈</span><br>      <span class="hljs-number">10</span>: invokevirtual #<span class="hljs-number">4</span>                  <span class="hljs-comment">//调用out的静态函数println()输出static code</span><br>      <span class="hljs-number">13</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>有趣的是没有<code>static&#123;&#125;</code>静态代码块时的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">anomymity</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;anomymity code&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] var0)</span> &#123;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//静态部分</span><br><span class="hljs-keyword">static</span> &#123;&#125;;<br>    Code:<br>       <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span><br>       <span class="hljs-number">2</span>: putstatic     #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Field value:I</span><br>       <span class="hljs-number">5</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>可以看到，<code>static&#123;&#125;</code>静态部分仍旧存在，并且静态变量<code>value</code>在其中赋值,了解后知道非常量的静态变量value是先准备阶段分配空间并初始化为0，然后在类加载的初始化阶段，类构造器&lt;clinit&gt;(也就是字节码中的<code>static&#123;&#125;</code>部分)会按语句在源文件中的顺序自动收集所以静态变量的赋值语句和静态语句块组合起来依次执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">anomymity</span> &#123;<br>     <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;static codes&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] var0)</span> &#123;<br>       System.out.println(anomymity.value);<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> value=<span class="hljs-number">10</span>；<br>&#125;<br><span class="hljs-comment">//字节码静态部分</span><br><span class="hljs-keyword">static</span> &#123;&#125;;<br>    Code:<br>       <span class="hljs-number">0</span>: getstatic     #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>       <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">5</span>                  <span class="hljs-comment">// String static codes</span><br>       <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>       <span class="hljs-number">8</span>: bipush        <span class="hljs-number">10</span><br>      <span class="hljs-number">10</span>: putstatic     #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Field value:I</span><br>      <span class="hljs-number">13</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>可以看到，<code>value</code>的赋值(<code>putstatic</code>)在静态语句块的执行之后了<br>并且此时静态语句块是不能引用value的，但是却能赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">anomymity</span> &#123;<br>     <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;static codes&quot;</span>+value);<span class="hljs-comment">//error：不能引用未定义的变量</span><br>        value=<span class="hljs-number">100</span>;                               <span class="hljs-comment">//right：可以赋值</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] var0)</span> &#123;<br>       System.out.println(anomymity.value);<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> value=<span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么我相信你已经懂了吧，那么来想一下，上面的代码如何没有error的那句，会输出什么呢？     </p><h4 id="9-java中无法判断输入数量的情况"><a href="#9-java中无法判断输入数量的情况" class="headerlink" title="9.java中无法判断输入数量的情况"></a>9.java中无法判断输入数量的情况</h4><p>首先先看一下c++是怎么处理了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a)!=<span class="hljs-number">1</span>)&#123;&#125;<br><span class="hljs-keyword">while</span>(cin&gt;&gt;a)&#123;&#125;<br></code></pre></td></tr></table></figure><p>只要看看函数返回值就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">scanf</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ... )</span></span>;<br></code></pre></td></tr></table></figure><p>scanf函数返回的int值是接收到的类型匹配的输入个数，示例中只接收一个int类型的a，所以判断返回值是否&#x3D;&#x3D;1即可    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> std::istream cin;<br>basic_istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;( T&amp; value );<br></code></pre></td></tr></table></figure><p>cin是一个istream对象，而&gt;&gt;是cin的一个重载的操作符，它返回一个basic_istream的引用,是istream的父类，相当又一个cin</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">cin&gt;&gt;a&gt;&gt;str&gt;&gt;b;    <span class="hljs-comment">//所以可以这样</span><br>((cin&gt;&gt;a)&gt;&gt;str)&gt;&gt;b;<span class="hljs-comment">//相当于这样</span><br><span class="hljs-comment">//但是问题来了</span><br><span class="hljs-keyword">while</span>(cin&gt;&gt;a)&#123;&#125;    <span class="hljs-comment">//cin会返回一个istream&amp; a_istream</span><br><span class="hljs-keyword">while</span>(a_istream)&#123;&#125;  <span class="hljs-comment">//我这么大一个istream怎么变成bool值的呢</span><br></code></pre></td></tr></table></figure><p>答案是重载强制类型转换操作符，当我们要将istream强制类型转换成bool的操作是<code>(bool)another</code>,那么我们只要看一下c++的源码就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//重载(bool)a_istream</span><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> _CLR_OR_THIS_CALL <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> !<span class="hljs-built_in">fail</span>();<br>&#125;<br><span class="hljs-comment">//重载!a_istream,防止while(!cin&gt;&gt;a)&#123;&#125;</span><br>_NODISCARD <span class="hljs-type">bool</span> __CLR_OR_THIS_CALL <span class="hljs-keyword">operator</span>!() <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fail</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>那么还有stream流是什么呢，好了好了，打住，我们先回到正题，那么在java中无法得知输入的整数个数怎么办,以下仅限于<code>Scanner</code>用法，有几种解决方案，我们来看一下吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">//第一种，最简单的，输入一个标志着结束的数字如0</span><br> <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br> <span class="hljs-type">int</span> sc;<br> <span class="hljs-keyword">do</span> &#123;<br>     sc=in.nextInt();<br> &#125;<span class="hljs-keyword">while</span>(sc!=<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">//第二种，用hasNextInt()方法，但是在console中要输入ctrl+z或者任意字符标志结束，如果输入ctrl+z，那么接下来的不能再进行输入</span><br> <span class="hljs-keyword">while</span>(in.hasNextInt())<br> &#123;<br>     sc=in.nextInt();<br> &#125;<br><br><span class="hljs-comment">//第三种，利用String，再转换成整数</span><br> String s=<span class="hljs-string">&quot;&quot;</span>;<br> <span class="hljs-keyword">while</span>(!(s=in.nextLine()).equals(<span class="hljs-string">&quot;&quot;</span>))<br> &#123;<br>     sc=Integer.parseInt(s);<br>     System.out.println(sc);<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>列表初始化的内部机制</title>
    <link href="/2023/06/26/initializer_list/"/>
    <url>/2023/06/26/initializer_list/</url>
    
    <content type="html"><![CDATA[<h3 id="1-列表初始化的内部机制———initializer-list-lt-T-gt"><a href="#1-列表初始化的内部机制———initializer-list-lt-T-gt" class="headerlink" title="1.列表初始化的内部机制———initializer_list&lt;T&gt;"></a>1.列表初始化的内部机制———initializer_list&lt;T&gt;</h3><p>我们在使用定义的类和标准库容器时，有时会用到花括号进行初始化   </p><p>定义一个类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>&#125;;<br></code></pre></td></tr></table></figure><p>创建一个类对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">A a1&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;             \\进行列表初始化<br>A a2&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;           \\error:无法从initialist_list转化为A<br>vector&lt;<span class="hljs-type">int</span>&gt; v1&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;   \\对容器进行<br>vector&lt;<span class="hljs-type">int</span>&gt; v2&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;  \\放进不同数量的实参<br></code></pre></td></tr></table></figure><p>从上面我们可以看出所谓的列表初始化就是利用标准库类型<code>initializer_list&lt;T&gt;</code>（即可变参数模板）然后进行类中构造函数创建一个对象，没有自定义的话会有一个生成的默认的。</p><p>以下是这个类模板的源码链接，与gcc-4.92的源码有十分甚至九分的相似   </p><p><a href="https://zh.cppreference.com/w/cpp/header/initializer_list">cppreference</a>  </p><p>想vector等stl库里的容器都有一个写好的以initializer_list为实参的构造函数，如上面的源码    </p><pre><code class="hljs">  vector(initializer_list&lt;value_type&gt; __l,       const allocator_type&amp; __a = allocator_type()):...  &#123;...&#125;  list(initializer_list&lt;value_type&gt; __l,       const allocator_type&amp; __a = allocator_type()):...       &#123; ... &#125;  //deque，forward_list等容器也有相同的构造函数     </code></pre><p>但是我还是想看一下<strong>visual studio</strong>关于<code>initializer_list&lt;T&gt;</code>里面的源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">_CONSTEXPR20_CONTAINER <span class="hljs-title">vector</span><span class="hljs-params">(initializer_list&lt;_Ty&gt; _Ilist, <span class="hljs-type">const</span> _Alloc&amp; _Al = _Alloc())</span></span><br><span class="hljs-function">        : _Mypair(_One_then_variadic_args_t&#123;</span>&#125;, _Al) &#123;<br>        <span class="hljs-keyword">auto</span>&amp;&amp; _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());<br>        _Container_proxy_ptr&lt;_Alty&gt; _Proxy(_Alproxy, _Mypair._Myval2);<br>        _Range_construct_or_tidy(_Ilist.<span class="hljs-built_in">begin</span>(), _Ilist.<span class="hljs-built_in">end</span>(), random_access_iterator_tag&#123;&#125;);<br>        _Proxy._Release();<br>    &#125;<br></code></pre></td></tr></table></figure><p>hhh，vs写成这样真的能看出他在写什么吗😅  </p><ul><li>[X]想翻译一下，但是没啥时间，而且有调用和宏太多了，找时间再说   </li><li>[√]只是测试一下markdown语法，顺便打打代码</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/06/22/hello-world/"/>
    <url>/2023/06/22/hello-world/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么要弄一个个人博客捏"><a href="#为什么要弄一个个人博客捏" class="headerlink" title="为什么要弄一个个人博客捏"></a>为什么要弄一个个人博客捏</h3><p>用来记录一下学习过程中收获到的知识和感悟，顺便加深一下印象，如果有一些生活中的个人感悟的话也会发一篇文章，主要是学习计算机相关的内容。(其实是看见很多大佬有个人blog，看起来好强的样子，所以也想有一个，感觉很帅气)</p>]]></content>
    
    
    
    <tags>
      
      <tag>随记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
